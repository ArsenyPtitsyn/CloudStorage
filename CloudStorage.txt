1. Мы создаём облачное хранилище! Облачное хранилище - это сервис, который позволяет хранить в облаке файлы, переименовывать их скачивать и загружать.
2. Приложение реализует архитектуру "клиент - сервер".
3. Функции сервера: 1) Хранение файлов (как, в чём хранить?) 2) Скачивание (как скачивать?) 3) Загрузить (как загружать?) 4) Файл менеджмент (переименовывание и возможно другие опции, которые захочется реализовать) 5) Делиться файлами с другими пользователями 
(по возможности) 6) Авторизация (организация шары может быть различной, например: шареная папка для всех, или шареная папка на группу, или распределить в базе данных гранты на файлы, то есть к каким то файлам даём доступ, к каким-то нет в самой базе) 7) Связь сервера с клиентами (С сервером связан такой вопрос, хотим ли мы одновременно исполнять запросы на скачивание/загрузку и переименовывание? Как это поддерживать? Например, отдельная линия для скачивания, загрузки и переименовывания - 3 потока на одного пользователя, либо экзекьютеры (независимые три линии), либо последовательно передавать как-то? Сигнальные байты (library)).
4. Функции клиента: 1) Связь? (TCP/IP) (как клиент подключится к серверу?) 2) GUI (total comander, win CSP, filezilla) JavaFX 3) Регистрация.
5. Маленькие файлы можно сериализовать, передавать в виде объектов "fileMsg" и зашить внутрь (имя, длина, байты) и сериализовать.
6. Большие файлы сериализовать невозможно из-за ограниченного количества памяти внутри JVM. Конечно, её можно увеличить, но этого делать не надо!
7. Как быть с большими файлами. Разделить на посылки по мегабайту fileMsgPart с булевым флагом end, который для всех частей будет false и только для последней части будет true, каждую из которых сериализовать.
8. Другой вариант передачи - байтовый протокол. То есть информация об имени (длина имени в символах с учётом точек и др. символов и с учётом стандарта (unicode, UTF-8...)), содержание файла (описательная информация 120б), содержимое файла. То есть нужно определить начало передачи и конец. Если мы определили содержимое, то конец достаточно очевиден - когда закончатся байты содержимого файла. А вот начало надо как-то определить (сигнальный байт). (Геморрой короче!)
9. В библиотеке java.nio полно методов, которые работают с файлами и их путями, в том числе можно поставить наблюдателей на определённую папку или файл и отслеживать всевозможные изменения производимые с данной папкой или файлом.
10. Канал - это труба, в которую мы можем послать байты с одной стороны и получить байты с другой стороны и в обратном направлении тоже можно!
11. В канал поступает класс ByteBuffer, который содержит в себе байты. В канал можно впечатать буффер, можно его забрать, а можно ещё впечатать другой буфер, третий, четвёртый. В этот канал можно сувать буферы из скольких-угодно потоков. На другом конце, можно прочитать буфер, а можно ещё свой буфер сунуть. У канала есть пропускная способность. Если в канале много буферов, то мы можем прочитать не ту посылку, в этот же самый момент ещё кто-то мог прочитать что-то из этих буферов...Работает это всё в двух режимах: в режиме блокировки, тогда всё хорошо (пока буфер не вычитаешь, никто другой ничего не сделает), но в этом нет соли; и в режиме селекторов (разбиваем посылки на подтипы). На канале регистрируется селектор (отбиратель (отбор)) (accept, read). Для подключения клиента нас интересует селектор accept, а для чтения нас интересует селектор read. Зааксепшенному клиенту мы можем зарегестрировать операцию чтения. То, что нам пришло мы читаем и обратно в канал отдаём. Можно назвать это некоторым "светофором". Создать селектор можно с помощью метода select(), при этом очередь блокируется. Заселекчиваем различные операции, а потом проходимся по ключикам селекта и выполняем какое-то действие для каждого ключика. Это даёт возможность обрабатывать в одном потоке до 10000 клиентов. Для чата 10000 клиентов - нормально будет держать один поток.
12. С ByteBuffer всё не очень просто. Внутри лежит массив байт. По дефолту там лежат нули. У байтбуфера есть указатель pos 
(position), lim (limit), cap (capacity). Когда мы что-то в него положили pos и limit сдвигаются. В режиме записи они сдвигаются на 1 при добавлении одного байта. Чтобы перевести из режима записи в режим чтения нужно сделать так, чтобы lim не был равен pos. Делается это очень просто: pos = 0; режим чтения итеративен. Каждый раз, когда мы вызываем чтение pos сдвигается на 1. Если в результате режима чтения pos превысит lim будет (index out of bounds exception). Читать то, что ещё не записано в буфер - нельзя. Превысить капасити нельзя (тоже index out of bounds exception). Перевести из режима записи в режим чтения - flip(); есть ещё команды rewind и clear.
13. Netty позволяет делать магию с файлами. С помощью простого метода можно реализовать передачу файла по частям. 